---
title: "Quantum Algorithms"
subtitle: "Algorithms and computational complexity (easy)"
author: "Leart Zuka"
date: "2025-01-08"
---

## What is a quantum algorithm?

In a sense a quantum algorithm isn't that much different from its classical sibling. Both execute a set of well defined instructions on their respective hardware (quantum or classical computer) in order to solve a specific problems, be it calculating the shortest possible route for a delivery driver to deliver his packages or find a certain data-entry in a database. 

Quantum algorithms adhere to the rules of quantum mechanics and abuse certain phenomena to `possibly` gain an advantage when compared to their classical counterparts, most notably [Superposition](/en/posts/entries/elementary/superposition) and [Interference](/en/posts/entries/elementary/interference). With these two phenomena at hand, quantum algorithms are able to check multiple solutions at once while simaltaneously throwing away the ones which are wrong.

## What are the most important quantum algorithms?

What follows is a summary of some of the more known quantum algorithms in the community which have been proven to achieve a significant boost in the time it takes to solve a problem and the amount of recources one needs to do so.

### Shor's Algorithm

Shor's algorithm is named after the mathematician who created it [Peter Shor](https://en.wikipedia.org/wiki/Peter_Shor), and is an algorithm for finding the prime factors of an integer.

---
#### **Prime factors and integers**

Integers are just regular numbers, so everything ranging from 0 to $\infty$ while going up in steps of 1.

Prime factors are also integers, which are only divisible by themselves and 1. Examples include:
$$
1,2,3,5,7,11,13,17,23,29,31,...
$$

---

But why is this of any interest for us? The most widely used encryption algorithm called [RSA](https://en.wikipedia.org/wiki/RSA_cryptosystem) basically works by picking two very large **prime numbers**, multiplying them with one another, performing some other set of calculations based on these two **prime numbers**, and them having a set of very large numbers which are then used as keys to decrypt and encrypt data. Classical computers struggle to crack these encryption algorithms, due to them not being able to efficiently get these numbers due to them being so large (_sidenote:_ they are able to crack them, but them needing years to do so isn't `efficient`). Using a quantum algorithm which is able to get the prime numbers of a very large number very fast thus results in a more efficient way of solving this issue and cracking the most widely used encryption system.

### Grover's Algorithm

![Search cat](/posts/assets/entries/algorithms/search_cat.png)

Grover's algorithm is what's known as a **quantum search algorithm**, and allows for a speed up in data searches. 
It was devised by the computer scientist [Lov Grover](https://en.wikipedia.org/wiki/Lov_Grover) in 1996 and is motivated by the following (although altered for the sake of funniness) example:

---

Imagine a of N boxes arranged in completely random order with a cat sitting in one of those boxes. In order to find the cat with a probability of $\frac{1}{2}$ any classical algorithm will need to look at a minimum of $\frac{N}{2}$ boxes. Quantum mechanical sysmtems can be in a [superposition](/en/posts/entries/elementary/superposition) of states and simaltaneously examine multiple names. With proper adjustment, sucessful computations reinforce each other while others [interfere](/en/posts/entries/elementary/interference) randomly. As a result the cat can be found by only looking at $\sqrt{N}$ boxes. [[Grover, 1996](https://arxiv.org/pdf/quant-ph/9605043)]

![Search cat](/posts/assets/entries/algorithms/find_cat.png)

---

What this essentially means is, that through the power of interference, the probability that a wrong result will get picked from our search algorithm will get reduced, while the the one for a right one will get amplified, thus becoming more apparent in a sea of possible results.

### Deutsch–Jozsa algorithm

The last algorithm we'll be looking at is the Deutsch-Jozsa algorithm which was proposed by the physicist [David Deutsch](https://en.wikipedia.org/wiki/David_Deutsch) and mathematician [Richard Jozsa](https://en.wikipedia.org/wiki/Richard_Jozsa). This quantum algorithm aims at uncovering wether a function is so called `balenced` or `constant`. But what does this mean? Here's a more hands-on-example, what this means and how the quantum computer is able to outperform a classical computer:

---

Imagine we have a coin that might be real (it has two different sides: “heads” and “tails”) or fake (both sides show the same pattern).
A classical computer would need to throw the coin at least twice — once for each side — to determine its authenticity.
A quantum computer, however, can make a single "throw" by sending a [superposition](/en/posts/entries/elementary/superposition) of “heads” and “tails,” and use [interference](/en/posts/entries/elementary/interference) to decide whether the coin is real or fake.

Imagine now having thuosand coins which you need to verify (we don't approve the exploitation of any scientist that needs to do such an experiment)! Flipping every single coin twice would result in a million flips, whereas a quantum computer could get the same result simply by "flipping" a thousand times.

---

Although this algorithm isn't really of any practical use, it's interesting for the sole fact alone that it was one of the first examples of a quantum algorithm being exponentially faster than any possible classical algorithm. 


## Final remarks

Does this mean that quantum computers with all their glory will always be faster when it comes to performing any task where modern classical computers fail?

Well that question is not so simple. Although quantum computers with all their quirks and gimmiks are very handy and do bring a lot of power with them, keeping them running and working efficiently can really ruffle one's feathers to say the least. 

You can read more about this [here](what_are_quantum_computers_good_for), where we dive deeper into the topic of what quantum computers are actually good for.
